import re

# Задание-1:
# Матрицы в питоне реализуются в виде вложенных списков:
# Пример. Дано:
matrix = [[1, 0, 8],
          [3, 4, 1],
          [0, 4, 2]]

# Выполнить поворот (транспонирование) матрицы
# Пример. Результат:
# matrix_rotate = [[1, 3, 0],
#                  [0, 4, 4],
#                  [8, 1, 2]]

print('\n Задание №1')
"""
не хард, т.к. затрагивали на уроке :)
"""
print(list(zip(*matrix)))

# Суть сложности hard: Решите задачу в одну строку

# Задание-2:
# Найдите наибольшее произведение пяти последовательных цифр в 1000-значном числе.
# Выведите произведение и индекс смещения первого числа последовательных 5-ти цифр.
# Пример 1000-значного числа:

from functools import reduce

print('\n Задание №2')

number = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450"""

"""
Интереснее было бы задать конечно количество повторяющихся символов и уже их группы
сопоставлять между собой.
Проверить работоспособность алгоритма можно заменив мокрую строку на r'(.)\1\1\1'
Однако, по условию задания дано фиксированное количество повторяющихся знаков = 5
При показателе 4 ответ будет 256 :) а если брать последовательность из 3х симоволов - уже 4096
Алгоритм изменения количества последовательных элементов в группе реализовал в
задаче в блоке нормал.
"""

regex = re.compile(r'(.)\1\1\1\1')
group_list = regex.findall(number)
print(group_list)

composition = 0

for i in group_list:
    if composition < reduce((lambda x, y: x * y), [int(n) for n in i*4]):
        composition = reduce((lambda x, y: x * y), [int(n) for n in i*4])

print(f'Наибольшее произведение повторяющихся 5ти чисел = {composition}')

# Задание-3 (Ферзи):
# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били
# друг друга. Вам дана расстановка 8 ферзей на доске.
# Определите, есть ли среди них пара бьющих друг друга.
# Программа получает на вход восемь пар чисел,
# каждое число от 1 до 8 — координаты 8 ферзей.
# Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.

import random
from functools import reduce

fight = 0

print('\n Задание №3')
"""
Реализация идет по координатам.
"""

# Генерируем и выводим доску
desk = [[0 for i in range(8)] for n in range(8)]

# Генерируем координаты ферзей
lisr_of_queens = []
for i in range(8):
    lisr_of_queens.append([random.randint(0, 7), random.randint(0, 7)])
print(lisr_of_queens)

# Расставляем ферзей :) для красоты и наглядности

for queen in lisr_of_queens:
    idx = queen[0]
    idy = queen[1]
    desk[idx][idy] = 1
for i in desk:
    print(i)

"""
Если в одной из строк больше одного ферзя - они попарно друг друга бьют
Аналогично с диагоналями и вертикалями
Для начала исключим горизонтали, потом вертикали через транспонирование,
потом диагонали через функцию
"""

for i in desk:
    if reduce(lambda x,y: x + y, i) > 1:
        print('есть ферзи, которые бьют друг друга по горизонтали')
        fight = fight + 1

desk_t = zip(*desk)
for i in desk_t:
    if reduce(lambda x, y: x + y, i) > 1:
        print('есть ферзи, которые бьют друг друга по вертикали')
        fight = fight + 1

# сгенерируем наклоненную в право "/" диагональ с индексами от лева вверх

n = 0
right_diagonal_list = [[]]
r = 1
rj = 1
for i in range(16):
    if i < 8:
        for j in range(i+1):
            right_diagonal_list[n].append(desk[i-j][j])
        n += 1
        right_diagonal_list.append([])
    else:
        for j in range(i-r):
            right_diagonal_list[n].append(desk[i-n+7-j][j+rj])
        r += 2
        n += 1
        rj += 1
        right_diagonal_list.append([])

for i in right_diagonal_list[:15]:
    if reduce(lambda x, y: x + y, i) > 1:
        print('есть ферзи, которые бьют друг на правой диагонали')
        fight = fight + 1

# сгенерируем наклоненную в лево "\" диагональ с индексами от лева вниз

n = 0
left_diagonal_list = [[]]
r = 1
rj = 1
for i in range(16):
    if i < 8:
        for j in range(i+1):
            left_diagonal_list[n].append(desk[7-i+j][j])
        n += 1
        left_diagonal_list.append([])
    else:
        for j in range(i-r):
            left_diagonal_list[n].append(desk[i-n+j][j+rj])
        r += 2
        n += 1
        rj += 1
        left_diagonal_list.append([])

for i in left_diagonal_list[:15]:
    if reduce(lambda x, y: x + y, i) > 1:
        print('есть ферзи, которые бьют друг на левой диагонали')
        fight = fight + 1

# ВСЕ ОСТАЛЬНЫЕ ПРИНТЫ МОЖНО УБРАТЬ - ВАЖЕН ТОЛЬКО ЭТОТ РЕЗУЛЬТАТИВНЫЙ
print('YES' if fight > 0 else 'NO')

